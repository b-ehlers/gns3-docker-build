#!/usr/bin/env python3

# Copyright (C) 2022 Bernhard Ehlers
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
build - (re)build outdated docker images

usage: build [image ...]

When running without an image arg, it checks all images,
if the directory containing its Dockerfile has changed or
its base image has been updated.

In some special cases a docker image needs a forced rebuild.
For that add the list of images, to be rebuild, to the arguments.
If the first image is "all", all images will be forcely rebuild.
Further images following "all" will be skipped.

The environment variable DOCKER_ACCOUNT must be set to the
registry/user of the Docker account to use.
"""

import os
import sys
import json
import re
import subprocess
import urllib.error
import urllib.request
import dateutil.parser

DOCKER_REGISTRY = "registry-1.docker.io"
DOCKER_AUTH = "auth.docker.io"
DOCKER_SERVICE = "registry.docker.io"

images = []
base_images = {}


def get_data(url, headers=None):
    """ get json formatted data from HTTP server """
    req = urllib.request.Request(url)
    if headers:
        for key, value in headers.items():
            req.add_header(key, value)
    with urllib.request.urlopen(req) as resp:
        data = json.load(resp)
    return data


def get_time_layers(repository):
    """
    get created time and layer info from the docker registry

    To retrieve this information the Docker Registry HTTP API V2 is used.
    https://docs.docker.com/registry/spec/api/
    """

    registry = DOCKER_REGISTRY
    auth = DOCKER_AUTH
    service = DOCKER_SERVICE

    # extract registry and tag from repository
    repo = repository.split("/")
    repo_parts = len(repo)
    if repo_parts == 1:
        repo.insert(0, "library")
    elif repo_parts >= 3:
        registry = repo.pop(0)
        auth = registry
        service = registry
    repo[-1], *tag = repo[-1].rsplit(":", 1)
    repo = "/".join(repo)
    if tag and tag[0]:
        tag = tag[0]
    else:
        tag = "latest"

    try:
        # Token authentication
        # https://docs.docker.com/registry/spec/auth/token/
        err_allowed = (403,)
        data = get_data("https://{auth}/token?service={service}&scope=repository:{repo}:pull"
                        .format(auth=auth, service=service, repo=repo))
        token = data["token"]

        # get manifest: GET /v2/{repo}/manifests/{tag}
        err_allowed = (401, 404)
        data = get_data("https://{registry}/v2/{repo}/manifests/{tag}"
                        .format(registry=registry, repo=repo, tag=tag),
                        {"Authorization": "Bearer " + token,
                         "Accept": "application/vnd.docker."
                                   "distribution.manifest.v2+json, "
                                   "application/vnd.docker."
                                   "distribution.manifest.list.v2+json"})
        err_allowed = ()
        if "manifests" in data:		# list of manifests
            for manifest in data["manifests"]:
                if manifest["platform"]["os"] == "linux" and \
                   manifest["platform"]["architecture"] == "amd64":
                    # get manifest: GET /v2/{repo}/manifests/{digest}
                    data = get_data("https://{registry}/v2/{repo}/manifests/{digest}"
                                    .format(registry=registry, repo=repo,
                                            digest=manifest["digest"]),
                                    {"Authorization": "Bearer " + token,
                                     "Accept": "application/vnd.docker."
                                               "distribution.manifest.v2+json"})
                    break
            else:
                sys.exit("{}: Missing architecture linux/amd64".format(repository))
        digest = data["config"]["digest"]

        # get repository information: GET /v2/{repo}/blobs/{digest}
        data = get_data("https://{registry}/v2/{repo}/blobs/{digest}"
                        .format(registry=registry, repo=repo, digest=digest),
                        {"Authorization": "Bearer " + token})
        return [dateutil.parser.parse(data["created"]).timestamp()] + \
               data["rootfs"]["diff_ids"]
    except json.JSONDecodeError:
        sys.exit("{}: {}".format(repository, "Invalid JSON"))
    except urllib.error.HTTPError as err:
        if err.code in err_allowed:
            return None
        sys.exit("{}: {}".format(repository, err))
    except urllib.error.URLError as err:
        sys.exit("{}: Connection failed: {}".format(repository, err.reason))
    except KeyError:
        sys.exit("{}: missing information from registry".format(repository))


def get_images():
    """ read 'images' configuration file

    Format of 'images':
    Name <tab> Directory [<tab> Base Image]

    If the base image is not given, it is extracted from <directory>/Dockerfile.
    """
    name_list = {}
    re_from = re.compile(r'\s*FROM\s+(\S+)', re.IGNORECASE)
    try:
        with open("images", "r") as img_file:
            lineno = 0
            for line in img_file:
                lineno += 1
                line = line.strip().split("#", 1)[0]
                img_split = [s for s in line.split('\t') if s]
                len_split = len(img_split)
                if len_split == 0:
                    continue
                if len_split == 2:
                    base = None
                elif len_split == 3:
                    base = img_split[2]
                else:
                    sys.exit("images: invalid number of fields in line {}"
                             .format(lineno))
                if img_split[0] in name_list:
                    sys.exit("images: multiple entries for {}"
                             .format(img_split[0]))
                name_list[img_split[0]] = True
                if not os.path.isdir(img_split[1]):
                    sys.exit("images: unknown directory '{}' in line {}"
                             .format(img_split[1], lineno))
                if base is None:	# extract base repository from Dockerfile
                    try:
                        with open(os.path.join(img_split[1], "Dockerfile"), "r") \
                             as dockerfile:
                            for dockerline in dockerfile:
                                match = re_from.match(dockerline)
                                if match:
                                    base = match.group(1)
                                    break
                    except OSError as err:
                        sys.exit("images: Dockerfile in line {}: {}"
                                 .format(lineno, err))
                    if base is None:
                        sys.exit("images: Dockerfile in line {}: {}"
                                 .format(lineno, "Missing FROM instruction"))
                images.append({"name": img_split[0],
                               "dir": img_split[1],
                               "base": base})
    except OSError as err:
        sys.exit("Can't read images file: {}".format(err))
    if not images:
        sys.exit("Empty image configuration")


def init_base_images():
    """ initialize base image data structure """
    name_list = {}
    for image in images:
        name_list[image["name"]] = True
    for image in images:
        base_name = image["base"]
        if base_name not in base_images:
            if base_name in name_list:
                full_name = docker_acct + base_name
            else:
                full_name = base_name
            base_images[base_name] = {"layer": None,
                                      "full_name": full_name,
                                      "need_dl": True}


def needs_rebuild(image):
    """ check if an image needs rebuilding """
    # update base_image layer, if empty
    base_img = base_images[image["base"]]
    if not base_img["layer"]:
        itime_layers = get_time_layers(base_img["full_name"])
        # store last layer
        if itime_layers and len(itime_layers) > 1:
            base_img["layer"] = itime_layers[-1]
        else:
            sys.exit("Missing base image: {}".format(image["base"]))

    # get image data
    itime_layers = get_time_layers(docker_acct + image["name"])
    if itime_layers:
        itime, *layers = itime_layers
        if image["name"] in base_images:
            base_images[image["name"]]["layer"] = layers[-1]
    else:
        itime = 0
        layers = []

    # check if base image has changed
    if base_img["layer"] not in layers:
        return True

    # check if build directory has changed, needs full git history
    try:
        proc = subprocess.run(["git", "log", "-n", "1", "--pretty=tformat:%ct",
                               image["dir"]],
                              capture_output=True,
                              check=True,
                              universal_newlines=True)
        mtime = int(proc.stdout.strip())
    except OSError as err:
        sys.exit("Can't run git: {}".format(err))
    except subprocess.CalledProcessError as err:
        sys.exit("Can't get commit date of {}: {}"
                 .format(image["name"], err.stderr.rstrip('\r\n')))
    except ValueError as err:
        sys.exit("Can't get commit date of {}: {}"
                 .format(image["name"], err))
    return mtime > itime


def build(image):
    """ build image """
    print("*** {}\n".format(image["name"]))
    base_img = base_images[image["base"]]
    try:
        if base_img["need_dl"]:		# need to download base image
            subprocess.run(["docker", "image", "pull",
                            base_img["full_name"]],
                           check=True)
            if image["base"] != base_img["full_name"]:
                subprocess.run(["docker", "image", "tag",
                                base_img["full_name"], image["base"]],
                               stdout=subprocess.DEVNULL,
                               check=True)
            base_img["need_dl"] = False

        build_options = ["--force-rm", "--tag", image["name"], image["dir"]]
        subprocess.run(["docker", "image", "build"] + build_options,
                       check=True)
        subprocess.run(["docker", "image", "tag",
                        image["name"], docker_acct + image["name"]],
                       stdout=subprocess.DEVNULL,
                       check=True)
        subprocess.run(["docker", "push", docker_acct + image["name"]],
                       check=True)
    except OSError as err:
        sys.exit("Can't run docker: {}".format(err))
    except subprocess.CalledProcessError as err:
        sys.exit(err.returncode)
    print()

    if image["name"] in base_images:	# just modified a base image
        try:
            proc = subprocess.run(["docker", "image", "inspect",
                                   "--format", '{{join .RootFS.Layers ","}}',
                                   image["name"]],
                                  capture_output=True,
                                  check=True,
                                  universal_newlines=True)
            # store last layer
            base_images[image["name"]]["layer"] = \
                proc.stdout.rstrip('\r\n').split(",")[-1]
            base_images[image["name"]]["need_dl"] = False
        except OSError as err:
            sys.exit("Can't run docker: {}".format(err))
        except subprocess.CalledProcessError as err:
            sys.exit("Can't get image layers of {}: {}"
                     .format(image["name"], err.stderr.rstrip('\r\n')))


# main
args = sys.argv[1:]
sys.stdout.reconfigure(line_buffering=True)

docker_acct = os.environ.get("DOCKER_ACCOUNT")
if not docker_acct:
    sys.exit("Environment variable DOCKER_ACCOUNT is not defined or empty")
if not docker_acct.endswith("/"):
    docker_acct += "/"

get_images()
init_base_images()
if args:				# image names from command line
    if args[0] == "all":		# rebuild all, except following images
        for img in images:
            if img["name"] not in args[1:]:
                build(img)
    else:				# rebuild images from args
        name2image = {}
        for img in images:
            name2image[img["name"]] = img
        for iname in args:
            if iname not in name2image:
                sys.exit("Image {} not found in 'images' configuration file"
                         .format(iname))
            build(name2image[iname])
else:					# build only changed images
    for img in images:
        if needs_rebuild(img):
            build(img)
