#!/usr/bin/env python3

# Copyright (C) 2022 Bernhard Ehlers
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
build - (re)build outdated docker images

usage: build [image ...]

The docker images and their properties are configured in the
file 'docker_images', located in the current directory.

Format of 'docker_images':
    Name <tab> Directory [<tab> Base Image] [<tab> Build Options]
        or
    Global Build Options

When running without an image arg, it checks all images,
if the directory containing its Dockerfile has changed or
its base image has been updated.

In some special cases a docker image needs a forced rebuild.
For that add the list of images, to be rebuild, to the arguments.
If the first image is "all", all images will be forcely rebuild.
Further images following "all" will be skipped.

The environment variable DOCKER_ACCOUNT must be set to the
registry/user of the Docker account to use.
"""

import os
import sys
import json
import re
import shlex
import subprocess
import urllib.error
import urllib.request
import dateutil.parser

images = []
base_images = {}
auth_url = {}


def get_data(url, headers=None):
    """ get json formatted data from HTTP server """
    req = urllib.request.Request(url)
    if headers:
        for key, value in headers.items():
            req.add_header(key, value)
    with urllib.request.urlopen(req) as resp:
        data = json.load(resp)
    return data


def get_time_layers(repository):
    """
    get created time and layer info from the docker registry

    To retrieve this information the Docker Registry HTTP API V2 is used.
    https://docs.docker.com/registry/spec/api/
    """

    # extract registry and tag from repository
    registry = "docker.io"
    repo = repository.split("/")
    if len(repo) >= 2 and ("." in repo[0] or ":" in repo[0]):
        registry = repo.pop(0)
    if registry == "docker.io":
        registry = "registry-1.docker.io"
        if len(repo) == 1:
            repo.insert(0, "library")
    repo[-1], *tag = repo[-1].rsplit(":", 1)
    repo = "/".join(repo)
    if tag and tag[0]:
        tag = tag[0]
    else:
        tag = "latest"

    err_allowed = ()
    try:
        # determine authentication URL
        if registry not in auth_url:
            try:
                with urllib.request.urlopen("https://{}/v2/".format(registry)) \
                     as resp:
                    resp.read()
                auth_url[registry] = None
            except urllib.error.HTTPError as err:
                if err.code != 401:
                    sys.exit("{}: {}".format(repository, err))
                www_auth = dict(re.findall(r'(\w+)\s*=\s*"([^"]+)"',
                                           err.headers["WWW-Authenticate"]))
                auth_url[registry] = "{realm}?service={service}" \
                                     .format(realm=www_auth["realm"],
                                             service=www_auth["service"])

        # Token authentication
        # https://docs.docker.com/registry/spec/auth/token/
        if auth_url[registry]:
            err_allowed = (403,)
            data = get_data("{auth_url}&scope=repository:{repo}:pull"
                            .format(auth_url=auth_url[registry], repo=repo))
            auth_header = {"Authorization": "Bearer " + data["token"]}
        else:
            auth_header = {}

        # get manifest: GET /v2/{repo}/manifests/{tag}
        err_allowed = (401, 404)
        data = get_data("https://{registry}/v2/{repo}/manifests/{tag}"
                        .format(registry=registry, repo=repo, tag=tag),
                        {**auth_header,
                         "Accept": "application/vnd.docker."
                                   "distribution.manifest.v2+json, "
                                   "application/vnd.docker."
                                   "distribution.manifest.list.v2+json"})
        err_allowed = ()
        if "manifests" in data:		# list of manifests
            for manifest in data["manifests"]:
                if manifest["platform"]["os"] == "linux" and \
                   manifest["platform"]["architecture"] == "amd64":
                    # get manifest: GET /v2/{repo}/manifests/{digest}
                    data = get_data("https://{registry}/v2/{repo}/manifests/{digest}"
                                    .format(registry=registry, repo=repo,
                                            digest=manifest["digest"]),
                                    {**auth_header,
                                     "Accept": "application/vnd.docker."
                                               "distribution.manifest.v2+json"})
                    break
            else:
                sys.exit("{}: Missing architecture linux/amd64".format(repository))
        digest = data["config"]["digest"]

        # get repository information: GET /v2/{repo}/blobs/{digest}
        data = get_data("https://{registry}/v2/{repo}/blobs/{digest}"
                        .format(registry=registry, repo=repo, digest=digest),
                        auth_header)
        return [dateutil.parser.parse(data["created"]).timestamp()] + \
               data["rootfs"]["diff_ids"]
    except json.JSONDecodeError:
        sys.exit("{}: {}".format(repository, "Invalid JSON"))
    except urllib.error.HTTPError as err:
        if err.code in err_allowed:
            return None
        sys.exit("{}: {}".format(repository, err))
    except urllib.error.URLError as err:
        sys.exit("{}: Connection failed: {}".format(repository, err.reason))
    except KeyError:
        sys.exit("{}: missing information from registry".format(repository))


def get_images():
    """ read images configuration file

    Format of 'docker_images':
        Name <tab> Directory [<tab> Base Image] [<tab> Build Options]
            or
        Global Build Options

    If the base image is not given, it is extracted from <directory>/Dockerfile.
    """
    image_file = "docker_images"
    gbl_options = []
    name_list = {}
    re_comment = re.compile(r'(?:^|\t) *#.*')
    re_from = re.compile(r'\s*FROM\s+(\S+)', re.IGNORECASE)
    try:
        with open(image_file, "r") as img_file:
            lineno = 0
            for line in img_file:
                lineno += 1
                line = re_comment.sub("", line.strip())
                img_split = [s for s in line.split('\t') if s]
                len_split = len(img_split)
                if len_split == 0:
                    continue
                if len_split == 1:
                    gbl_options = shlex.split(img_split[0])
                    while gbl_options and not gbl_options[0]:
                        gbl_options = gbl_options[1:]
                    continue
                base = None
                if len_split >= 3 and img_split[2][0] not in ('-', '"', "'"):
                    base = img_split.pop(2)
                    len_split -= 1
                options = gbl_options.copy()
                if len_split >= 3:
                    options += shlex.split(img_split.pop(2))
                    len_split -= 1
                if len_split != 2:
                    sys.exit("{}: invalid number of fields in line {}"
                             .format(image_file, lineno))
                if img_split[0] in name_list:
                    sys.exit("{}: multiple entries for {}"
                             .format(image_file, img_split[0]))
                name_list[img_split[0]] = True
                if not os.path.isdir(img_split[1]):
                    sys.exit("{}: unknown directory '{}' in line {}"
                             .format(image_file, img_split[1], lineno))
                if base is None:	# extract base repo from Dockerfile
                    try:
                        with open(os.path.join(img_split[1], "Dockerfile"),
                                  "r") as dockerfile:
                            for dockerline in dockerfile:
                                match = re_from.match(dockerline)
                                if match:
                                    base = match.group(1)
                                    break
                    except OSError as err:
                        sys.exit("{}: Dockerfile in line {}: {}"
                                 .format(image_file, lineno, err))
                    if base is None:
                        sys.exit("{}: Dockerfile in line {}: {}"
                                 .format(image_file, lineno,
                                         "Missing FROM instruction"))
                images.append({"name": img_split[0],
                               "dir": img_split[1],
                               "base": base,
                               "options": options})
    except OSError as err:
        sys.exit("Can't read images file: {}".format(err))
    if not images:
        sys.exit("Empty image configuration")


def init_base_images():
    """ initialize base image data structure """
    for image in images:
        base_name = image["base"]
        if base_name not in base_images:
            base_images[base_name] = {"layer": None}


def needs_rebuild(image):
    """ check if an image needs rebuilding """
    # update base_image layer, if empty
    base_img = base_images[image["base"]]
    if not base_img["layer"]:
        itime_layers = get_time_layers(image["base"])
        # store last layer
        if itime_layers and len(itime_layers) > 1:
            base_img["layer"] = itime_layers[-1]
        else:
            sys.exit("Missing base image: {}".format(image["base"]))

    # get image data
    full_name = image["name"]
    if "/" not in full_name:
        full_name = docker_acct + full_name
    itime_layers = get_time_layers(full_name)
    if itime_layers:
        itime, *layers = itime_layers
        if full_name in base_images:	# image is a base image
            base_images[full_name]["layer"] = layers[-1]
    else:
        itime = 0
        layers = []

    # check if base image has changed
    if base_img["layer"] not in layers:
        return True

    # check if build directory has changed, needs full git history
    try:
        proc = subprocess.run(["git", "log", "-n", "1", "--pretty=tformat:%ct",
                               image["dir"]],
                              capture_output=True,
                              check=True,
                              universal_newlines=True)
        mtime = int(proc.stdout.strip())
    except OSError as err:
        sys.exit("Can't run git: {}".format(err))
    except subprocess.CalledProcessError as err:
        sys.exit("Can't get commit date of {}: {}"
                 .format(image["name"], err.stderr.rstrip('\r\n')))
    except ValueError as err:
        sys.exit("Can't get commit date of {}: {}"
                 .format(image["name"], err))
    return mtime > itime


def build(image):
    """ build image """
    print("*** {}\n".format(image["name"]))
    full_name = image["name"]
    if "/" not in full_name:
        full_name = docker_acct + full_name
    try:
        subprocess.run(["docker", "buildx", "build"] + image["options"] + \
                       ["--push", "--tag", full_name, image["dir"]],
                       check=True)
    except OSError as err:
        sys.exit("Can't run docker: {}".format(err))
    except subprocess.CalledProcessError as err:
        sys.exit(err.returncode)
    print()

    if full_name in base_images:	# just modified a base image
        itime_layers = get_time_layers(full_name)
        # store last layer
        if itime_layers and len(itime_layers) > 1:
            base_images[full_name]["layer"] = itime_layers[-1]
        else:
            sys.exit("Can't get image layers of {}".format(image["name"]))


# main
args = sys.argv[1:]
sys.stdout.reconfigure(line_buffering=True)

docker_acct = os.environ.get("DOCKER_ACCOUNT")
if not docker_acct:
    sys.exit("Environment variable DOCKER_ACCOUNT is not defined or empty")
if not docker_acct.endswith("/"):
    docker_acct += "/"

get_images()
init_base_images()
if args:				# image names from command line
    if args[0] == "all":		# rebuild all, except following images
        for img in images:
            if img["name"] not in args[1:]:
                build(img)
    else:				# rebuild images from args
        name2image = {}
        for img in images:
            name2image[img["name"]] = img
        for iname in args:
            if iname not in name2image:
                sys.exit("Image {} not found in 'images' configuration file"
                         .format(iname))
            build(name2image[iname])
else:					# build only changed images
    for img in images:
        if needs_rebuild(img):
            build(img)
